<!-- start:source.tmpl.hbs -->
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
		<title>remote-mutator.js</title>
		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
		<link href="https://fonts.googleapis.com/css?family=PT+Mono" rel="stylesheet">
		<link type="text/css" rel="stylesheet" href="css/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="css/prism.min.css">
		<link type="text/css" rel="stylesheet" href="css/template.min.css">
			<link type="text/css" rel="stylesheet" href="../../.github/css/foodoc-overrides.css">
		<script type="text/javascript">
			window.TEMPLATE_OPTIONS = {"includeDate":true,"dateFormat":"Do MMM YYYY","systemName":"Warp Gate","systemSummary":"API Documentation","systemLogo":"img/hb-icon.bmp","systemColor":"","navMembers":[{"kind":"global","title":"Types","summary":"Definitions for commonly used api parameters and return values."},{"kind":"namespace","title":"API","summary":"Primary API for warp gate operations."}],"footer":"","copyright":"Warp Gate <a href=\"https://github.com/trioderegion/warpgate/blob/master/LICENSE\">Copyright Â© 2021</a> Matthew Haentschke","linenums":true,"collapseSymbols":true,"inverseNav":true,"inlineNav":false,"outputSourceFiles":true,"sourceRootPath":null,"disablePackagePath":true,"outputSourcePath":false,"showTableOfContents":true,"showAccessFilter":true,"analytics":null,"methodHeadingReturns":true,"sort":"longname, linenum, version, since","search":true,"favicon":null,"stylesheets":["../../.github/css/foodoc-overrides.css"],"scripts":[],"monospaceLinks":true,"cleverLinks":true};
			window.DOCLET_TOC_ENABLED = false;
			window.DOCLET_AFILTER_ENABLED = false;
		</script>
</head>
<body>
	<!-- start:navbar.hbs -->
	<header class="navbar navbar-default navbar-fixed-top navbar-inverse">
		<div class="container">
			<div class="navbar-header">
				<a class="navbar-brand branding-logo" href="index.html" style="background-image: url(img/hb-icon.bmp);">
					Warp Gate
				</a>
				<!-- displayed on small devices -->
				<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
			</div>
			<div class="navbar-collapse collapse" id="topNavigation">
				<ul class="nav navbar-nav">
								<li class="dropdown">
									<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Types<b class="caret"></b></a>
									<ul class="dropdown-menu">
											<li><a href="global.html#ComparisonKeys">ComparisonKeys</a></li>
											<li><a href="global.html#CrosshairsConfig">CrosshairsConfig</a></li>
											<li><a href="global.html#CrosshairsData">CrosshairsData</a></li>
											<li><a href="global.html#MutationData">MutationData</a></li>
											<li><a href="global.html#MutationOptions">MutationOptions</a></li>
											<li><a href="global.html#NoticeConfig">NoticeConfig</a></li>
											<li><a href="global.html#ParallelShow">ParallelShow</a></li>
											<li><a href="global.html#PostDelta">PostDelta</a></li>
											<li><a href="global.html#PostMutate">PostMutate</a></li>
											<li><a href="global.html#PostSpawn">PostSpawn</a></li>
											<li><a href="global.html#PreSpawn">PreSpawn</a></li>
											<li><a href="global.html#Shorthand">Shorthand</a></li>
											<li><a href="global.html#SpawningOptions">SpawningOptions</a></li>
											<li><a href="global.html#WarpOptions">WarpOptions</a></li>
											<li><a href="global.html#WorkflowOptions">WorkflowOptions</a></li>
									</ul>
								</li>
								<li class="dropdown">
									<a href="list_namespace.html" class="dropdown-toggle" data-toggle="dropdown">API<b class="caret"></b></a>
									<ul class="dropdown-menu">
											<li><a href="warpgate.html">warpgate</a></li>
											<li><a href="warpgate.abstract.html">warpgate.abstract</a></li>
											<li><a href="warpgate.crosshairs.html">warpgate.crosshairs</a></li>
											<li><a href="warpgate.dnd5e.html">warpgate.dnd5e</a></li>
											<li><a href="warpgate.event.html">warpgate.event</a></li>
											<li><a href="warpgate.plugin.html">warpgate.plugin</a></li>
											<li><a href="warpgate.util.html">warpgate.util</a></li>
									</ul>
								</li>
				</ul>
					<!-- start:lunr-search-navbar.hbs -->
					<form class="navbar-form navbar-right" role="search">
						<div class="input-group">
							<input type="text" class="form-control" placeholder="Search" id="lunr-search-input">
							<div class="input-group-btn">
								<button class="btn btn-default" id="lunr-search-submit">
									<i class="glyphicon glyphicon-search"></i>
								</button>
							</div>
						</div>
					</form>
					<!-- start:lunr-search-navbar.hbs -->		</div>
		</div>
	</header>
	<!-- end:navbar.hbs -->		<div class="page-header">
			<div class="container">
				<span class="kind">source</span>
				<h1><span class="name">remote-mutator.js</span></h1>
			</div>
		</div>
	<div class="container content">
		<div class="row">
			<div class="col-md-12 main-content">
		<section class="source-section">
			<article></article>
			<pre class="prettyprint source language-javascript line-numbers"><code class="language-javascript">/* 
 * This file is part of the warpgate module (https://github.com/trioderegion/warpgate)
 * Copyright (c) 2021 Matthew Haentschke.
 * 
 * This program is free software: you can redistribute it and/or modify  
 * it under the terms of the GNU General Public License as published by  
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with this program. If not, see &lt;http://www.gnu.org/licenses/>.
 */

import {logger} from './logger.js'
import {MODULE} from './module.js'
import {Comms} from './comms.js'
import {Mutator} from './mutator.js'

const NAME = "RemoteMutator";

export class RemoteMutator {

  static register() {
    RemoteMutator.settings();
  }

  static settings() {
    const config = true;
    const settingsData = {
      alwaysAccept: {
        scope: 'world', config, default: false, type: Boolean
      },
      suppressToast: {
        scope: 'world', config, default: false, type: Boolean
      },
      alwaysAcceptLocal: {
        scope: 'client', config, default: 0, type: Number,
        choices: {
          0: MODULE.localize('setting.option.useWorld'),
          1: MODULE.localize('setting.option.overrideTrue'),
          2: MODULE.localize('setting.option.overrideFalse'),
        }
      },
      suppressToastLocal: {
        scope: 'client', config, default: 0, type: Number,
        choices: {
          0: MODULE.localize('setting.option.useWorld'),
          1: MODULE.localize('setting.option.overrideTrue'),
          2: MODULE.localize('setting.option.overrideFalse'),
        }
      },
    };

    MODULE.applySettings(settingsData);
  }

  //responseData:
  //------
  //sceneId
  //userId
  //-------
  //accepted (bool)
  //tokenId
  //actorId
  //mutationId
  //updates (if mutate)

  /* create the needed trigger functions if there is a post callback to handle */
  static _createMutateTriggers( tokenDoc, {post = undefined}, options ) {

    const condition = (responseData) => {
      return responseData.tokenId === tokenDoc.id &amp;&amp; responseData.mutationId === options.name;
    }

    /* craft the response handler
     * execute the post callback */
    const promise = new Promise( (resolve) => {
      const handleResponse = async (responseData) => {

        /* if accepted, run our post callback */
        const tokenDoc = game.scenes.get(responseData.sceneId).getEmbeddedDocument('Token', responseData.tokenId);
        if (responseData.accepted) {
          const info = MODULE.format('display.mutationAccepted', {mName: options.name, tName: tokenDoc.name});

          const {suppressToast} = MODULE.getFeedbackSettings(options.overrides);
          if(!suppressToast) ui.notifications.info(info);
        } else {
          const warn = MODULE.format('display.mutationRejected', {mName: options.name, tName: tokenDoc.name});
          if(!options.overrides?.suppressReject) ui.notifications.warn(warn);
        }

        /* only need to do this if we have a post callback */
        if (post) await post(tokenDoc, responseData.updates, responseData.accepted);
        resolve(responseData);
        return;
      }

      warpgate.event.trigger(warpgate.EVENT.MUTATE_RESPONSE, handleResponse, condition);
    });

    return promise;
  }

  static _createRevertTriggers( tokenDoc, mutationName = undefined, {callbacks={}, options = {}} ) {

    const condition = (responseData) => {
      return responseData.tokenId === tokenDoc.id &amp;&amp; (responseData.mutationId === mutationName || !mutationName);
    }

    /* if no name provided, we are popping the last one */
    const mName = mutationName ? mutationName : warpgate.mutationStack(tokenDoc).last.name;

    /* craft the response handler
     * execute the post callback */
    const promise = new Promise(async (resolve) => {
      const handleResponse = async (responseData) => {
        const tokenDoc = game.scenes.get(responseData.sceneId).getEmbeddedDocument('Token', responseData.tokenId);

        /* if accepted, run our post callback */
        if (responseData.accepted) {
          const info = MODULE.format('display.revertAccepted', {mName , tName: tokenDoc.name});
          const {suppressToast} = MODULE.getFeedbackSettings(options.overrides);
          if(!suppressToast) ui.notifications.info(info);
        } else {
          const warn = MODULE.format('display.revertRejected', {mName , tName: tokenDoc.name});
          if(!options.overrides?.suppressReject) ui.notifications.warn(warn);
        }

        await callbacks.post?.(tokenDoc, responseData.updates, responseData.accepted);

        resolve(responseData);
        return;
      }

      warpgate.event.trigger(warpgate.EVENT.REVERT_RESPONSE, handleResponse, condition);
    });

    return promise;
  }

  static remoteMutate( tokenDoc, {updates, callbacks = {}, options = {}} ) {
    /* we need to make sure there is a user that can handle our resquest */
    if (!MODULE.firstOwner(tokenDoc)) {
      logger.error(MODULE.localize('error.noOwningUserMutate'));
      return false;
    }

    /* register our trigger for monitoring remote response.
     * This handles the post callback
     */
    const promise = RemoteMutator._createMutateTriggers( tokenDoc, callbacks, options );

    /* broadcast the request to mutate the token */
    Comms.requestMutate(tokenDoc.id, tokenDoc.parent.id, { updates, options });

    return promise;
  }

  /**
   *
   * @returns {Promise&lt;Array&lt;Object>>}
   */
  static async remoteBatchMutate( tokenDocs, {updates, callbacks = {}, options = {}} ) {
    /* follow normal protocol for initial requests.
     * if accepted, force accept and force suppress remaining token mutations
     * if rejected, bail on all further mutations for this owner */

    const firstToken = tokenDocs.shift();
    let results = [await warpgate.mutate(firstToken, updates, callbacks, options)];

    if (results[0].accepted) {

      const silentOptions = foundry.utils.mergeObject(options, { overrides: {alwaysAccept: true, suppressToast: true} }, {inplace: false});

      results = results.concat(tokenDocs.map( tokenDoc => {
        return warpgate.mutate(tokenDoc, updates, callbacks, silentOptions);
      }));

    } else {
      results = results.concat(tokenDocs.map( tokenDoc => ({sceneId: tokenDoc.parent.id, tokenId: tokenDoc.id, accepted: false})));
    }

    
    return results;
  }

  static remoteRevert( tokenDoc, {mutationId = null, callbacks={}, options = {}} = {} ) {
    /* we need to make sure there is a user that can handle our resquest */
    if (!MODULE.firstOwner(tokenDoc)) {
      logger.error(MODULE.format('error.noOwningUserRevert'));
      return false;
    }

    /* register our trigger for monitoring remote response.
     * This handles the post callback
     */
    const result = RemoteMutator._createRevertTriggers( tokenDoc, mutationId, {callbacks, options} );

    /* broadcast the request to mutate the token */
    Comms.requestRevert(tokenDoc.id, tokenDoc.parent.id, {mutationId, options});

    return result;
  }

  /**
   *
   * @returns {Promise&lt;Array&lt;Object>>}
   */
  static async remoteBatchRevert( tokenDocs, {mutationName = null, options = {}} = {} ) {

    /* follow normal protocol for initial requests.
     * if accepted, force accept and force suppress remaining token mutations
     * if rejected, bail on all further mutations for this owner */

    let firstToken = tokenDocs.shift();
    while( !!firstToken &amp;&amp; warpgate.mutationStack(firstToken).stack.length == 0 ) firstToken = tokenDocs.shift();

    if(!firstToken) return [];

    const results = [await warpgate.revert(firstToken, mutationName, options)];

    if(results[0].accepted) {

      const silentOptions = foundry.utils.mergeObject(options, {
          overrides: {alwaysAccept: true, suppressToast: true}
        }, {inplace: false}
      );

      results.push(...(tokenDocs.map( tokenDoc => {
        return warpgate.revert(tokenDoc, mutationName, silentOptions);
      })))
    } else {
      results.push(...tokenDocs.map( tokenDoc => ({sceneId: tokenDoc.parent.id, tokenId: tokenDoc.id, accepted: false})));
    }

    return results;
  }

  static async handleMutationRequest(payload) {
    
    /* First, are we the first player owner? If not, stop, they will handle it */
    const tokenDoc = game.scenes.get(payload.sceneId).getEmbeddedDocument('Token', payload.tokenId);

    if (MODULE.isFirstOwner(tokenDoc.actor)) {

      let {alwaysAccept: accepted, suppressToast} = MODULE.getFeedbackSettings(payload.options.overrides);
      
      if(!accepted) {
        accepted = await RemoteMutator._queryRequest(tokenDoc, payload.userId, payload.options.description, payload.updates)

        /* if a dialog is shown, the user knows the outcome */
        suppressToast = true;
      }

      let responseData = {
        sceneId: payload.sceneId,
        userId: game.user.id,
        accepted,
        tokenId: payload.tokenId,
        mutationId: payload.options.name,
        options: payload.options,
      }

      await warpgate.event.notify(warpgate.EVENT.MUTATE_RESPONSE, responseData);

      if (accepted) {
        /* first owner accepts mutation -- apply it */
        /* requests will never have callbacks */
        await Mutator.mutate(tokenDoc, payload.updates, {}, payload.options);
        const message = MODULE.format('display.mutationRequestTitle', {userName: game.users.get(payload.userId).name, tokenName: tokenDoc.name});
        
        if(!suppressToast) ui.notifications.info(message);
      }
    }
  }

  static async handleRevertRequest(payload) {

    /* First, are we the first player owner? If not, stop, they will handle it */
    const tokenDoc = game.scenes.get(payload.sceneId).getEmbeddedDocument('Token', payload.tokenId);

    if (MODULE.isFirstOwner(tokenDoc.actor)) {

      const stack = warpgate.mutationStack(tokenDoc);
      if( (stack.stack ?? []).length == 0 ) return;
      const details = payload.mutationId ? stack.getName(payload.mutationId) : stack.last;
      const description = MODULE.format('display.revertRequestDescription', {mName: details.name, tName: tokenDoc.name});

      let {alwaysAccept: accepted, suppressToast} = MODULE.getFeedbackSettings(payload.options.overrides);

      if(!accepted) {
        accepted = await RemoteMutator._queryRequest(tokenDoc, payload.userId, description, details );
        suppressToast = true;
      }

      let responseData = {
        sceneId: payload.sceneId,
        userId: game.user.id,
        accepted,
        tokenId: payload.tokenId,
        mutationId: payload.mutationId
      }

      await warpgate.event.notify(warpgate.EVENT.REVERT_RESPONSE, responseData);

      /* if the request is accepted, do the revert */
      if (accepted) {
        await Mutator.revertMutation(tokenDoc, payload.mutationId, payload.options);

        if (!suppressToast) { 
          ui.notifications.info(description);
        }
      }

    }
  }

  static async _queryRequest(tokenDoc, requestingUserId, description = 'warpgate.display.emptyDescription', detailsObject) {

    /* if this is update data, dont include the mutate data please, its huge */
    let displayObject = duplicate(detailsObject);
    if (displayObject.actor?.flags?.warpgate) {
      displayObject.actor.flags.warpgate = {};
    }

    displayObject = MODULE.removeEmptyObjects(displayObject);

    const details = RemoteMutator._convertObjToHTML(displayObject)

    const modeSwitch = {
      description: {label: MODULE.localize('display.inspectLabel'), value: 'inspect', content: `&lt;p>${game.i18n.localize(description)}&lt;/p>`},
      inspect: {label: MODULE.localize('display.descriptionLabel'), value: 'description', content: details }
    }

    const title = MODULE.format('display.mutationRequestTitle', {userName: game.users.get(requestingUserId).name, tokenName: tokenDoc.name});

    let userResponse = false;
    let modeButton = modeSwitch.description;

    do {
      userResponse = await warpgate.buttonDialog({buttons: [{label: MODULE.localize('display.findTargetLabel'), value: 'select'}, {label: MODULE.localize('display.acceptLabel'), value: true}, {label: MODULE.localize('display.rejectLabel'), value: false}, modeButton], content: modeButton.content, title, options: {top: 100}});

      if (userResponse === 'select') {
        if (tokenDoc.object) {
          tokenDoc.object.control({releaseOthers: true});
          await canvas.animatePan({x: tokenDoc.object.x, y: tokenDoc.object.y});
        }
      } else if (userResponse !== false &amp;&amp; userResponse !== true) {
        /* swap modes and re-render */
        modeButton = modeSwitch[userResponse];
      }

    } while (userResponse !== false &amp;&amp; userResponse !== true)

    return userResponse;

  }

  static _convertObjToHTML(obj) {
    const stringified = JSON.stringify(obj, undefined, '$SPACING');
    return stringified.replaceAll('\n', '&lt;br>').replaceAll('$SPACING', '&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;');
  }

}

</code></pre>
		</section>
			</div>
		</div>
	</div>
	<footer>
				<div class="copyright">Warp Gate <a href="https://github.com/trioderegion/warpgate/blob/master/LICENSE">Copyright Â© 2021</a> Matthew Haentschke</div>
			<div class="generated-by">Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on 6th Jun 2023 using the <a href="https://github.com/steveush/foodoc">FooDoc template</a>.</div>
	</footer>
	<script src="js/jquery.min.js"></script>
	<script src="js/bootstrap.min.js"></script>
	<script src="js/clipboard.min.js"></script>
	<script src="js/prism.min.js"></script>
	<script src="js/template.min.js"></script>
		<!-- start:lunr-search-modal.hbs -->
		<div class="modal fade" id="lunr-search-modal">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
						<h4 class="modal-title">Search results</h4>
					</div>
					<div class="modal-body" id="lunr-search-body">
					</div>
					<div class="modal-footer" id="lunr-search-footer">
						<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
					</div>
				</div><!-- /.modal-content -->
			</div><!-- /.modal-dialog -->
		</div>
		<!-- end:lunr-search-modal.hbs -->		<script src="js/lunr.min.js"></script>
	
</body>
</html>
<!-- end:source.tmpl.hbs -->